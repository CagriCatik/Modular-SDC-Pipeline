{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Modular Self-Driving Car Pipeline","text":"<p>The Modular SDC Pipeline provides a deterministic reference stack for the CarRacing-v3 environment. Each perception and control stage is implemented as a standalone component so that researchers can experiment with individual algorithms without rewriting the rest of the system.</p>"},{"location":"#why-this-repository-exists","title":"Why this repository exists","text":"<ul> <li>Deterministic baseline \u2013 every module is analytical, which makes the   behaviour debuggable and auditable.</li> <li>Explicit contracts \u2013 clearly defined interfaces between the perception,   planning, and control stages support incremental upgrades.</li> <li>Simulator ready \u2013 the <code>modular_pipeline.py</code> entry point can run in   headless or interactive mode using Gymnasium's CarRacing simulator.</li> </ul>"},{"location":"#end-to-end-data-flow","title":"End-to-end data flow","text":"<pre><code>flowchart LR\n    A[RGB observation] --&gt; B[LaneDetection&lt;br/&gt;Extract roadside splines]\n    B --&gt; C[Waypoint Prediction&lt;br/&gt;Centerline smoothing]\n    C --&gt; D[LateralController&lt;br/&gt;Stanley steering]\n    C --&gt; E[Target Speed Prediction]\n    E --&gt; F[LongitudinalController&lt;br/&gt;PID gas/brake]\n    D --&gt; G[Action vector]\n    F --&gt; G\n    G --&gt; H[SDC Wrapper / Gymnasium env]\n    H --&gt;|speed, reward| I[Modular Pipeline loop]\n    I --&gt;|next observation| A\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\npython modular_pipeline.py --no_display\n</code></pre> <p>Use <code>--score</code> to reproduce the leaderboard evaluation protocol.</p> <p>All module parameters are driven by <code>config.yml</code>. Supply <code>--config &lt;path&gt;</code> to load an alternative YAML file when experimenting with controller or planner settings.</p> <p>Running <code>python modular_pipeline.py</code> without <code>--no_display</code> launches the live dashboard so you can watch the detected lanes, planned waypoints, and velocity tracking behaviour evolve over time.</p>"},{"location":"#documentation-map","title":"Documentation map","text":"Topic Location Scientific reference with equations, tuning surfaces, and testing guidance <code>technical_reference.md</code>"},{"location":"#getting-help","title":"Getting help","text":"<ol> <li>Start with the scientific reference to understand module contracts and control laws.</li> <li>Inspect <code>modular_pipeline.py</code> for the command-line interface and configuration wiring.</li> <li>Open an issue when you encounter simulator- or build-specific problems.</li> </ol>"},{"location":"01_Lane-Detection/","title":"Lane Detection Pipeline","text":""},{"location":"01_Lane-Detection/#abstract","title":"Abstract","text":"<p>This document presents the scientific and algorithmic design of a lane detection pipeline for autonomous driving. The pipeline aims to extract geometric representations of lane boundaries from a simulated camera feed using deterministic, vision-based techniques. The system avoids any learning-based components, relying exclusively on analytical image processing, numerical optimization, and spline modeling. This design ensures interpretability, reproducibility, and full control over each stage of perception.</p>"},{"location":"01_Lane-Detection/#1-introduction","title":"1. Introduction","text":"<p>Lane detection serves as the perception front-end of a modular self-driving system. It provides the spatial foundation for path planning and vehicle control by estimating the left and right lane boundaries in image space and projecting them into a continuous parametric form.</p> <p>Unlike deep learning-based methods that infer lane geometry statistically, this pipeline decomposes the problem into three interpretable stages:</p> <ol> <li>Edge detection to identify potential lane markings.</li> <li>Edge assignment to group these features into coherent lane boundaries.</li> <li>Spline fitting to create a smooth geometric model suitable for downstream modules.</li> </ol> <p>This approach reflects the principle of explicit perception modeling, where the geometry of the environment is derived from first-order image properties and physical constraints rather than learned from data.</p>"},{"location":"01_Lane-Detection/#2-edge-detection","title":"2. Edge Detection","text":""},{"location":"01_Lane-Detection/#21-grayscale-conversion-and-cropping","title":"2.1 Grayscale Conversion and Cropping","text":"<p>Objective: Reduce image complexity and focus computation on the road surface.</p> <p>Converting the image to grayscale collapses redundant color information while preserving structural gradients critical for edge analysis. Cropping removes irrelevant features (sky, distant terrain, horizon) that can introduce high-frequency noise. The cropping height should be empirically optimized to include sufficient context for curvature estimation while maximizing computational efficiency.</p> <p>Mathematical Formulation: Given an RGB image ( I(x, y, c) ), the grayscale intensity is [ I_g(x, y) = 0.299R + 0.587G + 0.114B ] and the region of interest is defined as ( I_g[y_0:y_1, :] ) where ( y_0 ) and ( y_1 ) delimit the cropped section.</p>"},{"location":"01_Lane-Detection/#22-gradient-computation","title":"2.2 Gradient Computation","text":"<p>Objective: Detect regions of significant luminance change that correspond to lane markings.</p> <p>Gradients are computed as spatial derivatives: [ G_x = \\frac{\\partial I_g}{\\partial x}, \\quad G_y = \\frac{\\partial I_g}{\\partial y} ] and the gradient magnitude is: [ |G| = \\sqrt{G_x^2 + G_y^2} ]</p> <p>Operators such as Sobel or Scharr filters approximate these derivatives through convolution kernels. A dynamic threshold ( \\tau ) is applied: [ |G| = \\begin{cases} |G|, &amp; \\text{if } |G| &gt; \\tau \\ 0, &amp; \\text{otherwise} \\end{cases} ] to suppress noise and minor variations due to texture or shadows. Adaptive thresholding may further improve robustness under varying illumination.</p>"},{"location":"01_Lane-Detection/#23-rowwise-maxima-detection","title":"2.3 Rowwise Maxima Detection","text":"<p>Objective: Identify the pixel locations with maximal edge response per image row.</p> <p>Each row is treated as a one-dimensional signal ( G_y(x) ), where peaks correspond to likely lane boundaries. The <code>scipy.signal.find_peaks()</code> function can be applied with constraints on minimum peak distance, prominence, or width to ensure spatial consistency.</p> <p>This method assumes that lane markings appear as continuous, high-contrast curves extending across successive rows\u2014a valid assumption for most structured roads.</p>"},{"location":"01_Lane-Detection/#3-edge-association","title":"3. Edge Association","text":""},{"location":"01_Lane-Detection/#31-initialization-near-the-vehicle","title":"3.1 Initialization Near the Vehicle","text":"<p>The rows nearest to the vehicle provide the most reliable information because of minimal perspective distortion and higher pixel density. The first valid peaks in this region define the seed points for left and right boundaries: [ L_0 = \\arg\\max G_y(x) \\text{ for left region}, \\quad R_0 = \\arg\\max G_y(x) \\text{ for right region} ] These serve as anchors for subsequent boundary tracking.</p>"},{"location":"01_Lane-Detection/#32-sequential-boundary-propagation","title":"3.2 Sequential Boundary Propagation","text":"<p>Objective: Establish continuity of lane boundaries by linking edges across image rows.</p> <p>The propagation algorithm searches for nearest-neighbor peaks in the next row that minimize Euclidean distance from the current lane point: [ p_{n+1} = \\arg\\min_{q \\in \\text{peaks}_{n+1}} | q - p_n | ] This process continues iteratively until the top of the cropped image is reached. This sequential assignment enforces geometric coherence and handles moderate curvature and noise.</p> <p>A Kalman filter or simple motion model can be optionally incorporated to predict expected positions in the next row, improving resilience to occlusion and missing peaks.</p>"},{"location":"01_Lane-Detection/#4-spline-fitting","title":"4. Spline Fitting","text":""},{"location":"01_Lane-Detection/#41-parametric-representation","title":"4.1 Parametric Representation","text":"<p>The extracted left and right boundary points are modeled as smooth, parametric splines. Using <code>scipy.interpolate.splprep()</code>, we fit a curve: [ (x(s), y(s)) = f(s), \\quad s \\in [0, 1] ] where ( s ) is the normalized path length along the curve. This provides a differentiable and continuous description of the lane geometry.</p>"},{"location":"01_Lane-Detection/#42-spline-optimization","title":"4.2 Spline Optimization","text":"<p>The fitting process minimizes: [ E = \\sum_i | P_i - f(s_i) |^2 + \\lambda \\int_0^1 |f''(s)|^2 , ds ] where ( P_i ) are observed edge points and ( \\lambda ) controls smoothness. Larger ( \\lambda ) yields smoother splines but may underfit sharp bends; smaller values capture fine details at the expense of noise sensitivity.</p>"},{"location":"01_Lane-Detection/#43-practical-considerations","title":"4.3 Practical Considerations","text":"<ul> <li>Parameterization: Use chord-length or cumulative arc-length parameterization for uniform sampling.</li> <li>Numerical Stability: Remove duplicate points and normalize coordinates before fitting.</li> <li>Extrapolation: When boundary data are incomplete, low-order polynomial extrapolation can maintain continuity near the image horizon.</li> </ul>"},{"location":"01_Lane-Detection/#5-testing-and-validation","title":"5. Testing and Validation","text":""},{"location":"01_Lane-Detection/#51-experimental-evaluation","title":"5.1 Experimental Evaluation","text":"<p>Testing should be performed using the simulator under various road geometries and lighting conditions. Evaluation metrics may include:</p> <ul> <li>Detection accuracy: Mean distance between fitted spline and ground truth lane.</li> <li>Continuity: Proportion of frames with consistent left/right assignment.</li> <li>Robustness: Performance under partial occlusion, glare, or shadow artifacts.</li> </ul>"},{"location":"01_Lane-Detection/#52-parameter-tuning","title":"5.2 Parameter Tuning","text":"<p>Key tunable parameters:</p> <ul> <li>Gradient threshold ( \\tau ): Controls sensitivity to weak edges.</li> <li>Peak detection prominence: Reduces false positives.</li> <li>Spline smoothness ( \\lambda ): Balances fidelity and regularization.</li> </ul> <p>A grid search or Bayesian optimization approach may be used for systematic tuning.</p>"},{"location":"01_Lane-Detection/#6-scientific-significance","title":"6. Scientific Significance","text":"<p>This pipeline embodies the classical deterministic paradigm in autonomous vision. It demonstrates how geometric reasoning and signal processing can achieve robust environmental understanding without machine learning. From a control-theoretic perspective, it provides explainable inputs to downstream modules, enabling analytical stability proofs in feedback systems.</p> <p>Moreover, it provides a foundation for hybrid architectures, where deterministic perception is fused with data-driven refinement. Such integration would enable adaptive lane detection that remains interpretable and verifiable\u2014two essential qualities for safety-critical applications.</p>"},{"location":"01_Lane-Detection/#7-conclusion","title":"7. Conclusion","text":"<p>The lane detection module, as formulated here, translates raw visual input into a precise, parametric representation of road geometry. Through structured computation\u2014grayscale conversion, gradient analysis, geometric association, and spline modeling\u2014it achieves reliable performance using minimal assumptions.</p> <p>This approach demonstrates that interpretability and precision can coexist with efficiency, reinforcing the continuing relevance of physics-informed, algorithmic design in the age of machine learning.</p>"},{"location":"01_Lane-Detection/#lane-detection","title":"Lane Detection","text":"<p><code>LaneDetection</code> extracts left and right roadside splines from the 96\u00d796 RGB rendered frame.</p>"},{"location":"01_Lane-Detection/#processing-stages","title":"Processing stages","text":"<ol> <li>Cropping and grayscale conversion \u2013 removes the dashboard HUD and reduces    dimensionality while keeping gradients intact.</li> <li>Gradient magnitude \u2013 computes Sobel-style derivatives and thresholds weak    responses below <code>gradient_threshold</code>.</li> <li>Row-wise peak search \u2013 uses <code>scipy.signal.find_peaks</code> with a configurable    minimum spacing to produce candidate lane pixels.</li> <li>Sequential association \u2013 tracks the closest peak in each row to grow the    left and right lane hypotheses upward in the cropped image.</li> <li>Spline fitting \u2013 fits cubic B-splines (<code>scipy.interpolate.splprep</code>) once a    sufficient number of points is collected; otherwise the previous spline is    reused.</li> </ol>"},{"location":"01_Lane-Detection/#practical-guidance","title":"Practical guidance","text":"<ul> <li>Tune <code>cut_size</code> to balance field of view and computation. A value of 68 keeps   the road while removing most of the sky.</li> <li>Increase <code>gradient_threshold</code> when track textures cause false positives.</li> <li>The module preserves the last valid splines to prevent sudden controller   oscillations when the road temporarily disappears.</li> <li><code>plot_state_lane</code> is available for debugging; it overlays the predicted lanes   and optional waypoints on the rendered frame.</li> </ul>"},{"location":"01_Lane-Detection/#configuration-hooks","title":"Configuration hooks","text":"<p>Tune this module via <code>perception.lane_detection</code> in <code>config.yml</code>. Adjust the crop (<code>cut_size</code>), smoothing, and gradient thresholds to match new lighting or track layouts.</p>"},{"location":"02_Path-Planning/","title":"Path Planning","text":""},{"location":"02_Path-Planning/#abstract","title":"Abstract","text":"<p>Path planning is the cognitive layer of the modular autonomous driving pipeline. It transforms geometric lane information into a continuous, dynamically feasible trajectory by computing road-center waypoints, smoothing them through optimization, and assigning a curvature-dependent target speed. Unlike reactive control strategies, this approach explicitly formulates the geometry of motion, separating perception from decision-making. The system ensures stable navigation, energy efficiency, and safety under varying road geometries.</p>"},{"location":"02_Path-Planning/#1-introduction","title":"1. Introduction","text":"<p>In an autonomous driving stack, path planning bridges perception and control. It translates the lane geometry derived from vision into actionable spatial and temporal references for the vehicle. The planner\u2019s role is to generate a reference path that minimizes steering effort and maintains stability, while ensuring that the car remains within the detected lane boundaries.</p> <p>This module decomposes into three sequential subproblems:</p> <ol> <li>Road-center waypoint prediction \u2013 defines a discrete geometric skeleton of the lane center.</li> <li>Path smoothing \u2013 regularizes the trajectory to ensure curvature continuity and physical plausibility.</li> <li>Target speed prediction \u2013 modulates velocity based on curvature, enforcing safety and comfort.</li> </ol> <p>This formulation is deterministic, interpretable, and grounded in analytical optimization, adhering to the principles of model-based motion planning.</p>"},{"location":"02_Path-Planning/#2-road-center-waypoint-prediction","title":"2. Road Center Waypoint Prediction","text":""},{"location":"02_Path-Planning/#21-geometric-motivation","title":"2.1 Geometric Motivation","text":"<p>The lane boundaries, represented as parametric splines ( L(s) ) and ( R(s) ), define the feasible driving corridor. The road centerline ( C(s) ) can be estimated as the midpoint between these boundaries: [ C(s) = \\frac{L(s) + R(s)}{2}, \\quad s \\in [0, 1] ] This representation approximates the road\u2019s geometric symmetry and serves as the nominal path.</p>"},{"location":"02_Path-Planning/#22-discretization-into-waypoints","title":"2.2 Discretization into Waypoints","text":"<p>Step 1: Sampling along spline parameter space Let ( s_0, s_1, ..., s_N ) be equispaced parameters in [0, 1]. For each ( s_i ): [ L_i = L(s_i), \\quad R_i = R(s_i), \\quad C_i = \\frac{L_i + R_i}{2} ] The resulting set ( { C_i }_{i=1}^N ) forms a polyline approximating the lane center.</p> <p>Step 2: Parameter selection Including ( s_0 = 0 ) ensures that the first waypoint lies immediately ahead of the vehicle. The number of waypoints ( N ) governs the planning horizon\u2014too few reduce path granularity; too many increase computational load without substantial benefit.</p> <p>Step 3: Waypoint generation function The function <code>waypoint_prediction()</code> should therefore produce: [ \\text{waypoints} = [C_0, C_1, ..., C_N] ] where each ( C_i ) is expressed in vehicle-relative coordinates.</p>"},{"location":"02_Path-Planning/#23-numerical-considerations","title":"2.3 Numerical Considerations","text":"<ul> <li>Consistency: The sampling interval in ( s )-space should correspond approximately to uniform spatial distances to maintain constant waypoint density.</li> <li>Noise Sensitivity: Use low-order spline smoothing to mitigate jitter from lane boundary irregularities.</li> <li>Validation: Visual inspection and runtime testing under diverse lighting and curvature conditions ensure stability.</li> </ul> <p>This stage constructs a geometrically valid path that serves as the baseline for dynamic refinement.</p>"},{"location":"02_Path-Planning/#3-path-smoothing","title":"3. Path Smoothing","text":""},{"location":"02_Path-Planning/#31-theoretical-background","title":"3.1 Theoretical Background","text":"<p>The raw centerline may contain small discontinuities or oscillations due to imperfect perception. Path smoothing reformulates the trajectory as an energy minimization problem, seeking a trade-off between fidelity to the lane center and curvature minimization.</p> <p>The objective function is defined as: [ \\min_{x_1, \\ldots, x_N} \\sum_i | y_i - x_i |^2 - \\beta \\sum_n \\frac{(x_{n+1} - x_n) \\cdot (x_n - x_{n-1})}{|x_{n+1} - x_n| |x_n - x_{n-1}|} ] where:</p> <ul> <li>( y_i ): raw center points from perception</li> <li>( x_i ): optimized waypoints</li> <li>( \\beta ): curvature weighting coefficient</li> </ul> <p>The second term approximates the cosine of the turning angle, promoting alignment between consecutive segments. Maximizing this cosine value penalizes abrupt direction changes, enforcing curvature continuity.</p>"},{"location":"02_Path-Planning/#32-mathematical-interpretation","title":"3.2 Mathematical Interpretation","text":"<p>The curvature-related term, [ \\kappa_i = 1 - \\frac{(x_{i+1} - x_i) \\cdot (x_i - x_{i-1})}{|x_{i+1} - x_i| |x_i - x_{i-1}|} ] acts as a discrete analog of the second derivative along the curve, i.e., curvature energy. Minimizing this measure ensures smoother transitions, akin to minimizing bending energy in spline theory.</p> <p>The balance parameter ( \\beta ) controls the trade-off:</p> <ul> <li>Small ( \\beta ): prioritizes lane-center adherence.</li> <li>Large ( \\beta ): prioritizes geometric smoothness and corner cutting.</li> </ul> <p>This optimization is conceptually similar to elastic band models in robotics, where the path is treated as a flexible curve constrained by environmental boundaries.</p>"},{"location":"02_Path-Planning/#33-implementation-and-optimization","title":"3.3 Implementation and Optimization","text":"<p>The <code>curvature()</code> function should compute the curvature penalty across all consecutive triplets of points. Optimization can be achieved via gradient descent or direct analytical adjustments using local smoothing heuristics.</p> <p>Empirical tuning: Begin with ( \\beta \\in [0.1, 1.0] ) and incrementally adjust based on visual curvature smoothness. Excessive smoothing may lead to boundary violations; insufficient smoothing can result in jerky steering.</p>"},{"location":"02_Path-Planning/#4-target-speed-prediction","title":"4. Target Speed Prediction","text":""},{"location":"02_Path-Planning/#41-physical-motivation","title":"4.1 Physical Motivation","text":"<p>The optimal vehicle speed varies inversely with curvature: tighter turns require slower velocities to maintain lateral stability, while straight paths permit acceleration. This relationship stems from the centripetal acceleration constraint: [ a_c = \\frac{v^2}{r} \\leq a_{\\text{max}} ] where ( r ) is the turning radius and ( a_{\\text{max}} ) is the tire grip limit. Hence, speed must adapt dynamically to curvature magnitude.</p>"},{"location":"02_Path-Planning/#42-curvature-dependent-speed-model","title":"4.2 Curvature-Dependent Speed Model","text":"<p>The target velocity is defined by an exponential decay function: [ v_{\\text{target}} = (v_{\\max} - v_{\\min}) \\exp[-K_v \\cdot C] + v_{\\min} ] where ( C ) is the aggregated curvature measure: [ C = N - 2 - \\sum_n \\frac{(x_{n+1} - x_n) \\cdot (x_n - x_{n-1})}{|x_{n+1} - x_n| |x_n - x_{n-1}|} ] and ( K_v ) determines the sensitivity of speed to curvature.</p> <p>This formulation ensures smooth modulation between ( v_{\\min} ) and ( v_{\\max} ), yielding velocity continuity without abrupt acceleration changes.</p>"},{"location":"02_Path-Planning/#43-parameter-significance","title":"4.3 Parameter Significance","text":"<ul> <li>( v_{\\max} ): Upper bound for straight sections (e.g., 60 units).</li> <li>( v_{\\min} ): Lower bound for sharp turns (e.g., 30 units).</li> <li>( K_v ): Exponential curvature gain (default \u2248 4.5).</li> </ul> <p>Interpretation: When ( C \\to 0 ) (straight path), the exponential term approaches 1, driving ( v_{\\text{target}} \\approx v_{\\max} ). As ( C ) increases (tight curves), the exponential decays, reducing speed toward ( v_{\\min} ).</p>"},{"location":"02_Path-Planning/#44-implementation-and-testing","title":"4.4 Implementation and Testing","text":"<p>The <code>target_speed_prediction()</code> function computes curvature across the smoothed waypoints and applies the above equation. Testing should include:</p> <ul> <li>Straight-line motion: validate constant high-speed behavior.</li> <li>Mild curvature: ensure smooth deceleration and recovery.</li> <li>Sharp corners: confirm stability through gradual braking.</li> </ul> <p>Parameter tuning must consider both comfort and safety, ensuring that longitudinal acceleration and jerk remain within physically acceptable limits.</p>"},{"location":"02_Path-Planning/#5-integration-and-evaluation","title":"5. Integration and Evaluation","text":"<p>When integrated into the complete modular pipeline, the path planning subsystem outputs:</p> <ol> <li>A spatial path (set of smoothed waypoints).</li> <li>A temporal profile (target velocity along the path).</li> </ol> <p>These outputs feed directly into lateral and longitudinal control modules, forming the foundation of a model-based motion planner.</p> <p>Quantitative metrics for evaluation include:</p> <ul> <li>Path smoothness: curvature variance across waypoints.</li> <li>Lateral deviation: RMS distance from true lane center.</li> <li>Speed adaptation: correlation between curvature and velocity.</li> </ul> <p>Testing across diverse synthetic tracks establishes generalization and parameter robustness.</p>"},{"location":"02_Path-Planning/#6-scientific-significance","title":"6. Scientific Significance","text":"<p>This module exemplifies the geometric control paradigm in robotics: decomposing motion into spatial and temporal optimization governed by physical constraints. The explicit curvature penalty connects perceptual geometry to dynamic feasibility, aligning the mathematical path with the vehicle\u2019s dynamic envelope.</p> <p>Such deterministic planning frameworks remain crucial in safety-critical contexts where verifiability and interpretability outweigh raw adaptability. The combination of spline geometry, discrete curvature optimization, and exponential velocity modulation constitutes a theoretically grounded and computationally efficient solution for real-time autonomous navigation.</p>"},{"location":"02_Path-Planning/#7-conclusion","title":"7. Conclusion","text":"<p>The path planning module formalizes the transformation from detected lanes to drivable trajectories. Through rigorous geometric reasoning, it achieves a balance between adherence to lane structure and dynamic smoothness. The inclusion of curvature-based speed prediction extends spatial reasoning into the temporal domain, enabling motion that is both safe and efficient.</p> <p>This scientifically structured approach demonstrates that high-performance autonomous behavior can emerge from principled modeling, optimization, and control\u2014without reliance on black-box learning.</p>"},{"location":"02_Path-Planning/#waypoint-and-speed-planning","title":"Waypoint and Speed Planning","text":"<p>The planning layer converts lane splines into a drivable centreline and assigns an appropriate target speed.</p>"},{"location":"02_Path-Planning/#waypoint_prediction","title":"<code>waypoint_prediction</code>","text":"<ul> <li>Accepts two spline tuples <code>(t, c, k)</code> from <code>LaneDetection</code>.</li> <li>Evaluates both splines across <code>num_waypoints</code> samples and averages them to   obtain a centreline.</li> <li>Optionally optimises the points with L-BFGS-B to reduce curvature while   staying close to the centreline (<code>way_type=\"smooth\"</code>, weighted by   <code>smoothing_beta</code>).</li> <li>Falls back to a straight-ahead path if spline evaluation fails or produces   non-finite values.</li> </ul>"},{"location":"02_Path-Planning/#target_speed_prediction","title":"<code>target_speed_prediction</code>","text":"<ul> <li>Computes heading changes across the first <code>num_waypoints_used</code> samples and   maps curvature to a speed using an exponential decay.</li> <li>Guarantees non-negative output and enforces a lower bound (<code>min_speed</code>).</li> <li><code>K_v</code> controls how aggressively the controller slows down for tight bends.</li> </ul>"},{"location":"02_Path-Planning/#tuning-checklist","title":"Tuning checklist","text":"Symptom Suggested change Vehicle cuts corners Increase <code>num_waypoints</code> or the smoothing weight <code>smoothing_beta</code>. Oscillatory steering Reduce <code>num_waypoints_used</code> so speed reacts less to far-away curvature. Vehicle too cautious Raise <code>max_speed</code> or lower <code>K_v</code>."},{"location":"02_Path-Planning/#configuration-hooks","title":"Configuration hooks","text":"<p>Tune waypoint generation via <code>planning.waypoints</code> in <code>config.yml</code> and adjust the speed profile through <code>planning.target_speed</code>. Switching <code>way_type</code> to <code>center</code> disables smoothing for faster convergence when the splines are reliable.</p>"},{"location":"03_Lateral-Control/","title":"Lateral Control of a Vehicle","text":""},{"location":"03_Lateral-Control/#abstract","title":"Abstract","text":"<p>Lateral control governs the steering dynamics of an autonomous vehicle, ensuring that it follows a planned trajectory with minimal deviation. This section formalizes the Stanley Controller, a nonlinear feedback law originally developed for the DARPA Grand Challenge, and its enhancement via damping control for improved stability and smoothness. The system\u2019s foundation lies in geometric error minimization and dynamic response shaping, aligning classical control theory with practical vehicle dynamics.</p>"},{"location":"03_Lateral-Control/#1-introduction","title":"1. Introduction","text":"<p>The lateral control subsystem transforms spatial path references into steering commands, effectively keeping the vehicle aligned with its intended trajectory. In the context of model-based autonomy, the objective is to minimize cross-track and orientation errors while ensuring dynamic stability across varying speeds.</p> <p>The Stanley Controller is a geometric, nonlinear control law that balances accuracy and smoothness through speed-dependent correction. It requires no model of the vehicle\u2019s internal dynamics, making it computationally efficient and analytically tractable\u2014ideal for real-time embedded systems.</p>"},{"location":"03_Lateral-Control/#2-stanley-controller-theory","title":"2. Stanley Controller Theory","text":""},{"location":"03_Lateral-Control/#21-conceptual-foundation","title":"2.1 Conceptual Foundation","text":"<p>Lateral control errors are decomposed into two orthogonal components:</p> <ul> <li>Cross-Track Error ( d(t) ): The perpendicular distance between the vehicle\u2019s center of mass and the nearest point on the desired path.</li> <li>Orientation Error ( \\psi(t) ): The difference between the vehicle\u2019s heading angle and the tangent of the path at that nearest point.</li> </ul> <p>The controller aims to drive both ( d(t) ) and ( \\psi(t) ) asymptotically toward zero, aligning the vehicle\u2019s trajectory with the reference path.</p>"},{"location":"03_Lateral-Control/#22-control-law-derivation","title":"2.2 Control Law Derivation","text":"<p>The Stanley control law combines these two errors into a single nonlinear equation: [ \\delta_{SC}(t) = \\psi(t) + \\arctan\\left(\\frac{k \\cdot d(t)}{v(t)}\\right) ] where:</p> <ul> <li>( \\delta_{SC}(t) ): steering command,</li> <li>( k ): lateral gain coefficient,</li> <li>( v(t) ): vehicle velocity,</li> <li>( d(t) ): lateral deviation,</li> <li>( \\psi(t) ): orientation misalignment.</li> </ul> <p>Interpretation:</p> <ul> <li>The first term corrects the heading to align with the path tangent.</li> <li>The second term introduces a geometric correction proportional to the cross-track error, scaled by ( 1/v(t) ) to reduce oversteering at high speeds.</li> </ul> <p>The arctangent function introduces nonlinear saturation, ensuring the output steering angle remains bounded. This boundedness is critical for vehicle stability, preventing excessive steering inputs when large errors occur at low speeds.</p>"},{"location":"03_Lateral-Control/#23-dynamic-and-nonlinear-behavior","title":"2.3 Dynamic and Nonlinear Behavior","text":"<p>The controller\u2019s behavior evolves dynamically with velocity:</p> <ul> <li>Low speeds: ( \\frac{k d(t)}{v(t)} ) dominates, allowing aggressive corrections to align with the path.</li> <li>High speeds: The same term diminishes, producing gentler corrections to prevent oscillatory or unstable behavior.</li> </ul> <p>This inherent speed-adaptive response is a hallmark of nonlinear geometric controllers and contributes to the Stanley controller\u2019s stability across operating regimes.</p>"},{"location":"03_Lateral-Control/#24-analytical-stability-insight","title":"2.4 Analytical Stability Insight","text":"<p>Under small-angle approximations (( \\psi \\approx \\sin(\\psi) ), ( \\tan(\\delta) \\approx \\delta )), the closed-loop lateral dynamics can be linearized as: [ \\dot{d}(t) = v(t) \\sin(\\psi) \\approx v(t)\\psi, \\quad \\dot{\\psi}(t) = -\\frac{v(t)}{L}\\delta_{SC}(t) ] Substituting the control law yields an asymptotically stable system for positive ( k ). This ensures convergence of both ( d(t) ) and ( \\psi(t) ) to zero in steady-state conditions.</p>"},{"location":"03_Lateral-Control/#3-stanley-controller-implementation","title":"3. Stanley Controller Implementation","text":""},{"location":"03_Lateral-Control/#31-computational-procedure","title":"3.1 Computational Procedure","text":"<p>To implement the control law in <code>lateral_control.py</code>, the following sequence is used:</p> <ol> <li> <p>Orientation Error Computation</p> </li> <li> <p>Derive the path tangent vector ( \\hat{t}_p ) from the first two waypoints.</p> </li> <li>Obtain the vehicle\u2019s heading vector ( \\hat{t}_v ).</li> <li> <p>Compute ( \\psi(t) = \\text{atan2}(\\hat{t}_p \\times \\hat{t}_v, \\hat{t}_p \\cdot \\hat{t}_v) ).</p> </li> <li> <p>Cross-Track Error Calculation</p> </li> <li> <p>Compute the signed perpendicular distance from the vehicle\u2019s position to the nearest path segment:      [      d(t) = (\\mathbf{p}_v - \\mathbf{p}_r) \\cdot \\hat{n}_p      ]      where ( \\hat{n}_p ) is the unit normal to the path at the closest reference point ( \\mathbf{p}_r ).</p> </li> <li> <p>Steering Command</p> </li> <li> <p>Combine the terms using the Stanley control law.</p> </li> <li> <p>Prevent division by zero by adding a small numerical constant ( \\epsilon ) to ( v(t) ).</p> </li> <li> <p>Gain Tuning</p> </li> <li> <p>Empirically determine ( k ) to balance responsiveness and stability.</p> <ul> <li>Too low: slow convergence and large steady-state error.</li> <li>Too high: oscillatory motion and oversteering at high speeds.</li> </ul> </li> </ol> <p>Typical tuning begins with ( k \\in [0.2, 1.0] ) for small-scale autonomous systems and may be scaled with vehicle length or steering ratio for full-scale models.</p>"},{"location":"03_Lateral-Control/#32-implementation-considerations","title":"3.2 Implementation Considerations","text":"<ul> <li>Sensor Noise: Both ( d(t) ) and ( \\psi(t) ) are sensitive to measurement noise; applying a low-pass filter or exponential moving average improves robustness.</li> <li>Real-Time Constraints: The controller must execute at a fixed update rate, typically 20\u201350 Hz, synchronized with perception and actuation subsystems.</li> <li>Deadband Handling: To prevent unnecessary oscillations at very low speeds, a minimum velocity threshold (e.g., 1 m/s) can disable the steering correction term.</li> </ul>"},{"location":"03_Lateral-Control/#4-damping-enhancement","title":"4. Damping Enhancement","text":""},{"location":"03_Lateral-Control/#41-motivation","title":"4.1 Motivation","text":"<p>While the Stanley controller achieves convergence, its pure form may exhibit oscillatory steering behavior, especially at high gains or under noisy perception. To mitigate this, a damping term is added to the control output to suppress abrupt steering changes, acting as a temporal low-pass filter.</p>"},{"location":"03_Lateral-Control/#42-damped-control-law","title":"4.2 Damped Control Law","text":"<p>The augmented control equation becomes: [ \\delta(t) = \\delta_{SC}(t) - D \\cdot [\\delta_{SC}(t) - \\delta(t-1)] ] where ( D ) is the damping coefficient.</p> <p>This introduces first-order inertia into the steering dynamics, blending the new control signal with the previous output to produce gradual transitions.</p> <p>Interpretation:</p> <ul> <li>( D = 0 ): No damping, immediate response.</li> <li>( D = 1 ): Full damping, steering frozen at the previous value.</li> <li>Typical operational range: ( D \\in [0.1, 0.5] ).</li> </ul>"},{"location":"03_Lateral-Control/#43-control-theoretic-interpretation","title":"4.3 Control-Theoretic Interpretation","text":"<p>The damping mechanism functions analogously to a lead-lag compensator, stabilizing the closed-loop system by reducing phase lag and limiting overshoot. In the Laplace domain, the transfer function from steering command to response effectively gains a low-pass filter: [ H(s) = \\frac{1}{1 + D s} ] This slows the steering response without altering steady-state accuracy, improving ride comfort and control robustness.</p>"},{"location":"03_Lateral-Control/#44-parameter-tuning","title":"4.4 Parameter Tuning","text":"<p>Empirical adjustment of ( D ) should account for vehicle dynamics:</p> <ul> <li>High ( D ): Smooth but sluggish steering. Suitable for high-speed cruising.</li> <li>Low ( D ): Quick response, but may induce high-frequency oscillations on winding roads.   A balanced setting ensures fast convergence without sacrificing lateral stability.</li> </ul>"},{"location":"03_Lateral-Control/#5-scientific-context-and-discussion","title":"5. Scientific Context and Discussion","text":"<p>The Stanley controller embodies the geometric control philosophy\u2014directly regulating spatial errors rather than relying on full dynamic models. Its nonlinearity allows for state-dependent gain modulation, yielding robust performance across a broad range of speeds and curvatures.</p> <p>In control theory terms, it provides nonlinear feedback linearization around the path-following manifold. The damping augmentation extends this concept by introducing controlled temporal dynamics, akin to the behavior of critically damped second-order systems.</p> <p>Though originally heuristic, the Stanley controller has been shown experimentally to produce bounded errors and stability in real-world conditions. Its simplicity, transparency, and empirical reliability make it foundational in both academic and industrial autonomous driving systems.</p>"},{"location":"03_Lateral-Control/#6-conclusion","title":"6. Conclusion","text":"<p>The Lateral Control Module implements a mathematically elegant and empirically robust steering mechanism based on the Stanley Controller, enhanced with damping for dynamic smoothness.</p> <p>Through geometric reasoning, bounded nonlinear feedback, and adaptive response shaping, it enables precise path tracking while preserving stability at varying speeds.</p> <p>This design demonstrates that deterministic, model-based control laws\u2014rooted in geometry and feedback theory\u2014can achieve high-performance steering behavior in autonomous systems, providing a scientifically grounded alternative to black-box learning controllers.</p>"},{"location":"03_Lateral-Control/#lateral-control","title":"Lateral Control","text":"<p><code>LateralController</code> implements a Stanley controller with damping to drive the steering command.</p>"},{"location":"03_Lateral-Control/#control-law","title":"Control law","text":"<ul> <li>Uses the first segment of the waypoint path to estimate the centreline   heading.</li> <li>Computes the cross-track error from the nearest waypoint.</li> <li>Applies the Stanley formula <code>\u03b4 = \u03c8 + arctan(k\u00b7d / v)</code> with a small damping term   to suppress oscillations at low speed.</li> <li>Clamps the output to \u00b10.4 rad and scales to the <code>[-1, 1]</code> range expected by   CarRacing.</li> </ul>"},{"location":"03_Lateral-Control/#operational-notes","title":"Operational notes","text":"<ul> <li>Call <code>reset()</code> when starting a new episode to clear the steering memory.</li> <li>Provide <code>speed</code> in the same units as the longitudinal controller (the wrapper   returns metres per second).</li> <li>Invalid waypoints trigger the previous steering command instead of zero to   maintain continuity.</li> </ul>"},{"location":"03_Lateral-Control/#configuration-hooks","title":"Configuration hooks","text":"<p>Modify Stanley gains through <code>control.lateral</code> in <code>config.yml</code>. Increase the damping constant on noisy tracks or raise the gain constant when the vehicle lags behind the centreline.</p>"},{"location":"04_Longitudinal-Control/","title":"Longitudinal Control of a Vehicle","text":""},{"location":"04_Longitudinal-Control/#abstract","title":"Abstract","text":"<p>Longitudinal control governs the forward motion of an autonomous vehicle by modulating throttle and braking to maintain a target velocity derived from the path planner. This section presents a rigorous, scientific formulation of the PID (Proportional\u2013Integral\u2013Derivative) controller, its discrete implementation for digital systems, and tuning strategies for stable and responsive speed control. The objective is to minimize velocity tracking error while ensuring comfort, safety, and dynamic stability under variable road and vehicle conditions.</p>"},{"location":"04_Longitudinal-Control/#1-introduction","title":"1. Introduction","text":"<p>Longitudinal control is the temporal counterpart to lateral control. While lateral control manages the spatial trajectory, longitudinal control dictates how fast the vehicle progresses along that trajectory.</p> <p>The design must satisfy two constraints:</p> <ol> <li>Accuracy \u2014 precisely follow the desired speed profile.</li> <li>Smoothness \u2014 avoid jerky accelerations or overshoot that degrade comfort or traction.</li> </ol> <p>The PID controller remains the cornerstone of industrial control due to its simplicity, interpretability, and well-understood dynamics. When properly tuned, it achieves near-optimal performance for a wide range of linear and quasi-linear systems, including vehicle longitudinal dynamics.</p>"},{"location":"04_Longitudinal-Control/#2-the-pid-control-law","title":"2. The PID Control Law","text":""},{"location":"04_Longitudinal-Control/#21-control-objective","title":"2.1 Control Objective","text":"<p>The goal is to minimize the instantaneous velocity tracking error: [ e(t) = v_{\\text{target}}(t) - v(t) ] where ( v_{\\text{target}} ) is the desired velocity profile and ( v(t) ) is the measured velocity.</p> <p>The controller outputs a unified control signal ( u(t) ), determining throttle or braking intensity. The system continuously updates ( u(t) ) at discrete time intervals ( \\Delta t ).</p>"},{"location":"04_Longitudinal-Control/#22-discrete-pid-formulation","title":"2.2 Discrete PID Formulation","text":"<p>The control law is implemented in discrete time as: [ u(t) = K_p e(t) + K_i \\sum_{l=0}^{t} e(l) \\Delta t + K_d \\frac{e(t) - e(t-1)}{\\Delta t} ]</p> <p>Where:</p> <ul> <li>( K_p ) controls proportional response to instantaneous error.</li> <li>( K_i ) accumulates past errors to remove steady-state bias.</li> <li>( K_d ) anticipates error change to dampen oscillations.</li> </ul> <p>The throttle and brake commands are derived directly from ( u(t) ): [ a_{\\text{gas}}(t) = \\max(0, u(t)), \\quad a_{\\text{brake}}(t) = \\max(0, -u(t)) ]</p> <p>This ensures mutual exclusivity\u2014only one actuator is active at a time, consistent with vehicle hardware constraints.</p>"},{"location":"04_Longitudinal-Control/#23-control-theoretic-interpretation","title":"2.3 Control-Theoretic Interpretation","text":"<p>The PID controller represents a closed-loop negative feedback system. The proportional term reacts to instantaneous deviations, the integral term ensures zero steady-state error, and the derivative term predicts future behavior.</p> <p>In the Laplace domain, the continuous PID transfer function is: [ G_c(s) = K_p + \\frac{K_i}{s} + K_d s ]</p> <p>The proportional component contributes immediate corrective action. The integral component adds memory, driving long-term accuracy. The derivative component introduces predictive damping, shaping system response akin to velocity feedback in mechanical systems.</p> <p>Together, they form a controller capable of first-order and second-order dynamic compensation, approximating ideal behavior for a second-order plant\u2014such as vehicle acceleration governed by engine torque and drag forces.</p>"},{"location":"04_Longitudinal-Control/#3-understanding-the-components","title":"3. Understanding the Components","text":""},{"location":"04_Longitudinal-Control/#31-proportional-term-k_p-et","title":"3.1 Proportional Term ( K_p e(t) )","text":"<ul> <li>Reacts to current deviation.</li> <li>Larger ( K_p ) increases responsiveness but risks oscillations and overshoot if the system becomes underdamped.</li> <li>Physically, this term controls the aggressiveness of throttle and braking response.</li> </ul>"},{"location":"04_Longitudinal-Control/#32-integral-term-k_i-sum-el","title":"3.2 Integral Term ( K_i \\sum e(l) )","text":"<ul> <li>Compensates for system bias\u2014for example, aerodynamic drag or rolling resistance\u2014by accumulating past errors.</li> <li>Eliminates steady-state offset where the car stabilizes below target speed.</li> <li>However, excessive accumulation leads to integral windup, a nonlinear phenomenon where the integrator drives the actuator beyond its physical limits.</li> </ul>"},{"location":"04_Longitudinal-Control/#33-derivative-term-k_d-et-et-1","title":"3.3 Derivative Term ( K_d [e(t) - e(t-1)] )","text":"<ul> <li>Responds to the rate of error change, providing anticipatory correction.</li> <li>Helps prevent overshoot and stabilizes transient response, functioning as a form of velocity feedback.</li> <li>Sensitivity to measurement noise requires signal filtering (e.g., a first-order low-pass filter).</li> </ul>"},{"location":"04_Longitudinal-Control/#4-integral-windup-and-anti-windup-techniques","title":"4. Integral Windup and Anti-Windup Techniques","text":""},{"location":"04_Longitudinal-Control/#41-problem-definition","title":"4.1 Problem Definition","text":"<p>In real systems, actuators saturate. For example, throttle cannot exceed 100%, and braking cannot go below 0. When such limits are reached, the integral term continues to accumulate error, leading to overshoot once the actuator is released.</p>"},{"location":"04_Longitudinal-Control/#42-mitigation-strategies","title":"4.2 Mitigation Strategies","text":"<ol> <li> <p>Integral Clamping</p> </li> <li> <p>Bound the integral accumulation term within a predefined range:      [      I_{\\text{clamped}} = \\text{clip}(I, -I_{\\max}, I_{\\max})      ]</p> </li> <li> <p>Prevents runaway accumulation.</p> </li> <li> <p>Conditional Integration</p> </li> <li> <p>Freeze integral updates when the control signal reaches saturation limits.</p> </li> <li> <p>Back-Calculation Anti-Windup</p> </li> <li> <p>Introduce a feedback term that subtracts the difference between saturated and unsaturated control signals, effectively \"bleeding off\" accumulated error.</p> </li> </ol> <p>These techniques ensure numerical stability and enable predictable response recovery after saturation events such as sudden stops or steep inclines.</p>"},{"location":"04_Longitudinal-Control/#5-pid-parameter-tuning","title":"5. PID Parameter Tuning","text":""},{"location":"04_Longitudinal-Control/#51-empirical-tuning-methodology","title":"5.1 Empirical Tuning Methodology","text":"<p>PID tuning is an iterative experimental process, as real vehicle dynamics are nonlinear and time-varying. The general tuning procedure:</p> <ol> <li> <p>Proportional Phase:</p> </li> <li> <p>Set ( K_i = 0, K_d = 0 ).</p> </li> <li> <p>Increase ( K_p ) until the system responds rapidly without oscillating excessively.</p> </li> <li> <p>Derivative Phase:</p> </li> <li> <p>Gradually increase ( K_d ) to reduce overshoot and improve damping.</p> </li> <li> <p>Observe the step response\u2014higher ( K_d ) produces smoother convergence but can amplify sensor noise.</p> </li> <li> <p>Integral Phase:</p> </li> <li> <p>Introduce ( K_i ) to eliminate steady-state error.</p> </li> <li>Apply anti-windup logic to constrain integral growth.</li> </ol>"},{"location":"04_Longitudinal-Control/#52-quantitative-evaluation","title":"5.2 Quantitative Evaluation","text":"<p>Performance can be measured by:</p> <ul> <li>Rise time: time to reach 90% of the target speed.</li> <li>Settling time: time to stabilize within \u00b15% of the target.</li> <li>Overshoot: percentage by which speed exceeds target.</li> <li>Steady-state error: residual difference after settling.</li> </ul> <p>Optimization methods such as Ziegler\u2013Nichols or Cohen\u2013Coon rules provide initial parameter estimates, but fine-tuning is typically empirical due to the vehicle\u2019s nonlinear friction and torque dynamics.</p>"},{"location":"04_Longitudinal-Control/#53-parameter-sensitivity","title":"5.3 Parameter Sensitivity","text":"Parameter Function Increasing Value Effects ( K_p ) Immediate error correction Faster response, higher overshoot ( K_i ) Long-term bias elimination Lower steady-state error, possible oscillations ( K_d ) Predictive damping Reduced overshoot, noise sensitivity <p>The tuning must adapt to external conditions such as road slope, aerodynamic drag, and tire friction. Hence, practical implementations often employ gain scheduling, adjusting gains dynamically based on vehicle speed or load.</p>"},{"location":"04_Longitudinal-Control/#6-system-implementation-and-validation","title":"6. System Implementation and Validation","text":""},{"location":"04_Longitudinal-Control/#61-discrete-implementation-in-software","title":"6.1 Discrete Implementation in Software","text":"<p>The controller can be implemented in <code>longitudinal_control.py</code> as follows:</p> <ul> <li>Maintain persistent variables for ( e(t-1) ) and the integral sum.</li> <li>Apply clamping to limit the control signal within actuator bounds.</li> <li>Use consistent sampling intervals (e.g., 50\u2013100 Hz) to ensure numerical stability.</li> </ul>"},{"location":"04_Longitudinal-Control/#62-testing-and-visualization","title":"6.2 Testing and Visualization","text":"<p><code>test_longitudinal_control.py</code> provides time-series plots of target vs. actual velocity. Through iterative tests, the user can visualize convergence, overshoot, and steady-state performance, tuning gains accordingly.</p>"},{"location":"04_Longitudinal-Control/#63-safety-considerations","title":"6.3 Safety Considerations","text":"<ul> <li>Avoid excessively high ( K_p ) or ( K_i ) values, which can cause aggressive acceleration or braking.</li> <li>Validate under varying conditions\u2014flat, uphill, and downhill\u2014to ensure robustness.</li> </ul>"},{"location":"04_Longitudinal-Control/#7-scientific-context-and-discussion","title":"7. Scientific Context and Discussion","text":"<p>From a control theory perspective, the PID controller embodies a low-order approximation of optimal feedback. It can be derived from linear quadratic regulator (LQR) principles under simplified plant dynamics, where proportional, integral, and derivative actions correspond to state, accumulation, and rate feedback respectively.</p> <p>Despite its simplicity, the PID framework remains prevalent due to:</p> <ul> <li>Computational efficiency\u2014requires no model inversion or matrix operations.</li> <li>Interpretability\u2014each term has a clear physical meaning.</li> <li>Adaptability\u2014can be extended into advanced architectures such as PI-D cascades, adaptive PID, or model predictive control (MPC).</li> </ul> <p>In vehicle dynamics, longitudinal PID control provides a foundation for higher-level adaptive cruise control, traction management, and energy-optimized driving strategies.</p>"},{"location":"04_Longitudinal-Control/#8-conclusion","title":"8. Conclusion","text":"<p>The longitudinal control system translates velocity commands into actionable throttle and braking inputs through a discrete PID controller. By combining reactive, integrative, and predictive behaviors, it achieves stable speed tracking across diverse driving conditions.</p> <p>Scientific rigor in design\u2014proper discretization, anti-windup protection, and gain tuning\u2014ensures both robustness and comfort. This module demonstrates how classical control theory, when precisely implemented and tuned, continues to outperform complex learning-based systems in safety-critical tasks requiring stability, interpretability, and verifiability.</p>"},{"location":"04_Longitudinal-Control/#longitudinal-control","title":"Longitudinal Control","text":"<p><code>LongitudinalController</code> uses a PID regulator to map the target speed to gas and brake commands.</p>"},{"location":"04_Longitudinal-Control/#pid-design","title":"PID design","text":"<ul> <li>Proportional (<code>KP</code>) \u2013 matches the steady-state acceleration to the speed   error.</li> <li>Integral (<code>KI</code>) \u2013 compensates for drag or road grade; the accumulated error   is clamped by <code>integral_windup_limit</code> to avoid overshoot.</li> <li>Derivative (<code>KD</code>) \u2013 damps oscillations by reacting to error changes. The   implementation guards against division by zero by enforcing a minimum <code>dt</code>.</li> </ul>"},{"location":"04_Longitudinal-Control/#command-translation","title":"Command translation","text":"<p>The PID output is interpreted as longitudinal force:</p> <ul> <li>Positive command \u2192 throttle, clipped to <code>[0, max_gas]</code> (default 0.8).</li> <li>Negative command \u2192 brake, clipped to <code>[0, max_brake]</code> (default 0.8).</li> <li>Both channels cannot be active simultaneously.</li> </ul>"},{"location":"04_Longitudinal-Control/#episode-management","title":"Episode management","text":"<p>Call <code>reset()</code> before each episode to clear the integrator and derivative state. The controller maintains optional histories (<code>speed_history</code>, <code>target_speed_history</code>) that can be plotted for debugging with <code>plot_speed</code>.</p>"},{"location":"04_Longitudinal-Control/#recommended-gains","title":"Recommended gains","text":"Condition KP KI KD Notes Default flat track 0.08 0.01 0.02 Aggressive but stable at 50 Hz. High curvature sections 0.06 0.02 0.03 Slightly more damping to handle rapid slowdowns. Slippery surfaces 0.04 0.02 0.0 Avoids derivative noise from wheel slip. <p>Tune KP first, then KI, and finally KD. Always re-validate using the leaderboard seeds defined in <code>config.yml</code>.</p>"},{"location":"04_Longitudinal-Control/#configuration-hooks","title":"Configuration hooks","text":"<p>Adjust PID gains, integrator clamp, and actuator saturation via <code>control.longitudinal</code> in <code>config.yml</code>. Reduce <code>max_gas</code>/<code>max_brake</code> when testing hardware-in-the-loop rigs to respect actuator limits.</p>"},{"location":"architecture/","title":"System Architecture","text":"<p>The pipeline follows a perception \u2192 planning \u2192 control loop. Each module is pure-Python and interacts through NumPy arrays, which makes the stack portable across operating systems and reproducible in CI.</p>"},{"location":"architecture/#runtime-orchestration","title":"Runtime orchestration","text":"<p>The <code>ModularPipeline</code> class coordinates the environment and the controllers. It starts by resetting the wrapped Gymnasium environment, extracts the initial speed from the <code>info</code> dictionary, and then iterates until termination or a fixed horizon is reached.</p> <p>The pipeline is parameterised by <code>config.yml</code>, which configures the factories for perception, planning, and control as well as the simulator wrapper.</p> <pre><code>sequenceDiagram\n    participant Env as CarRacing-v3\n    participant Wrap as SDC_Wrapper\n    participant Pipeline as ModularPipeline\n    participant Perception as LaneDetection\n    participant Planning as Waypoint &amp; Speed\n    participant Control as Lateral + Longitudinal\n\n    Pipeline-&gt;&gt;Wrap: reset(seed?)\n    Wrap-&gt;&gt;Env: reset\n    Env--&gt;&gt;Wrap: obs, info(speed)\n    Wrap--&gt;&gt;Pipeline: obs, speed\n\n    loop per simulation step\n        Pipeline-&gt;&gt;Perception: lane_detection(obs)\n        Perception--&gt;&gt;Pipeline: roadside splines\n        Pipeline-&gt;&gt;Planning: waypoint_prediction(...)\n        Planning--&gt;&gt;Pipeline: vehicle-frame waypoints\n        Pipeline-&gt;&gt;Planning: target_speed_prediction(...)\n        Planning--&gt;&gt;Pipeline: desired speed\n        Pipeline-&gt;&gt;Control: stanley(waypoints, speed)\n        Pipeline-&gt;&gt;Control: control(speed, target)\n        Control--&gt;&gt;Pipeline: steer, gas, brake\n        Pipeline-&gt;&gt;Wrap: step([steer, gas, brake])\n        Wrap-&gt;&gt;Env: step\n        Env--&gt;&gt;Wrap: next_obs, reward, done, trunc, info\n        Wrap--&gt;&gt;Pipeline: masked_obs, clipped_reward, speed\n    end\n</code></pre>"},{"location":"architecture/#timing-and-coordinate-frames","title":"Timing and coordinate frames","text":"<ul> <li>Simulator tick \u2013 CarRacing integrates at 50 Hz (\u0394t = 0.02 s). The   longitudinal controller accepts an explicit <code>dt</code> argument to match this rate.</li> <li>Image frame \u2013 Lane detection works in cropped image coordinates. Splines   are evaluated in <code>[x, y]</code> pixels with the vehicle origin placed at the bottom   centre of the crop.</li> <li>Vehicle frame \u2013 Waypoint generation and all control logic use the vehicle   frame where <code>x</code> points forward and <code>y</code> points left.</li> </ul>"},{"location":"architecture/#failure-handling","title":"Failure handling","text":"<ol> <li>Lane detection retains the previous spline when no reliable peaks are found.</li> <li>Waypoint generation falls back to a straight centreline if splines are    missing or numerically unstable.</li> <li>Target-speed estimation lower-bounds the command to maintain forward    progress when curvature cannot be estimated.</li> <li>The longitudinal PID controller clamps its integral term to avoid windup and    saturates gas/brake commands to the 0\u20130.8 range required by the simulator.</li> </ol>"},{"location":"configuration/","title":"Configuration Reference","text":"<p>All runtime parameters are defined in <code>config.yml</code>. The file is loaded at startup and determines how the simulator, perception, planning, and control layers are wired together. Provide an alternate YAML file with <code>--config</code> to experiment with different controller gains or planner strategies without editing code.</p> <pre><code>python modular_pipeline.py --config configs/aggressive.yaml --no_display\n</code></pre>"},{"location":"configuration/#high-level-flow","title":"High-level flow","text":"<pre><code>flowchart TD\n    A[config.yml] --&gt; B[Environment factory]\n    A --&gt; C[Lane detection]\n    A --&gt; D[Waypoint &amp; speed planners]\n    A --&gt; E[Control gains]\n    B --&gt; F[ModularPipeline]\n    C --&gt; F\n    D --&gt; F\n    E --&gt; F\n    F --&gt; G[CarRacing-v3 simulator]\n</code></pre>"},{"location":"configuration/#sections","title":"Sections","text":"Path Description <code>environment</code> Gymnasium environment ID, render mode, and wrapper toggles. <code>runtime</code> Episode horizon (<code>max_steps</code>) and integration timestep (<code>timestep_seconds</code>). <code>perception.lane_detection</code> Crop height, spline smoothing, and gradient thresholds. <code>planning.waypoints</code> Number of waypoints, smoothing beta, and whether to use centreline or smoothed curves. <code>planning.target_speed</code> Curvature-to-speed mapping (<code>num_waypoints_used</code>, <code>max_speed</code>, <code>min_speed</code>, <code>curvature_gain</code>). <code>control.lateral</code> Stanley controller gains (<code>gain_constant</code>, <code>damping_constant</code>). <code>control.longitudinal</code> PID gains, integrator clamp, and actuator saturation. <code>evaluation</code> Default evaluation episode count and leaderboard seeds."},{"location":"configuration/#example-override","title":"Example override","text":"<p>Create a file such as <code>configs/rainy.yaml</code> to adapt the controllers to slippery conditions:</p> <pre><code>environment:\n  kwargs:\n    render_mode: rgb_array\n\ncontrol:\n  lateral:\n    gain_constant: 0.02\n    damping_constant: 0.02\n  longitudinal:\n    KP: 0.05\n    KI: 0.015\n    KD: 0.0\n    max_gas: 0.6\n    max_brake: 0.9\n</code></pre> <p>Running <code>python modular_pipeline.py --config configs/rainy.yaml --no_display</code> uses these parameters while leaving the default <code>config.yml</code> untouched.</p>"},{"location":"technical_reference/","title":"Scientific Reference Manual","text":"<p>The modular self-driving pipeline consists of analytically defined perception, planning, and control stages operating on the Gymnasium <code>CarRacing-v3</code> simulator. Each stage obeys an explicit interface so that alternative algorithms can be swapped in without touching the remaining stack.</p>"},{"location":"technical_reference/#architectural-overview","title":"Architectural overview","text":"<pre><code>flowchart LR\n    I[Observation $x_t$] --&gt;|Perception| P[LaneDetectionModule\\\\n$\\mathcal{L}$]\n    P --&gt;|Lanes| W[WaypointPlanningModule\\\\n$\\mathcal{P}_w$]\n    W --&gt;|Waypoints| S[TargetSpeedPlanningModule\\\\n$\\mathcal{P}_v$]\n    S --&gt;|Reference speed| C1[LateralControlModule\\\\n$\\mathcal{C}_\\delta$]\n    W --&gt; C1\n    S --&gt; C2[LongitudinalControlModule\\\\n$\\mathcal{C}_a$]\n    C1 --&gt; A[Action vector $u_t$]\n    C2 --&gt; A\n    A --&gt; E[Gymnasium environment]\n    E --&gt;|reward, speed| M[ModularPipeline]\n    M --&gt;|next observation| I\n</code></pre> <p>At runtime the <code>ModularPipeline</code> orchestrator (see <code>modular_pipeline.py</code>) drives these modules according to the configuration loaded from <code>config.yml</code>.</p>"},{"location":"technical_reference/#timing-model","title":"Timing model","text":"<p>Episodes run at a configurable discrete timestep $\\Delta t$ (default $1/50\\,\\text{s}$). For step index $k$, the pipeline evaluates modules with the context</p> <p>$$ \\mathcal{C}_k = {k,\\ v_k,\\ \\Delta t}, $$</p> <p>where $v_k$ is the simulator-reported longitudinal speed.</p>"},{"location":"technical_reference/#perception-lane-boundary-extraction","title":"Perception: lane boundary extraction","text":"<p>The perception stage crops the RGB observation to the region in front of the vehicle, converts it to intensity, and derives horizontal/vertical gradients $\\partial_x I$ and $\\partial_y I$. The gradient magnitude used for peak searching is</p> <p>$$ G = |\\partial_x I| + |\\partial_y I|. $$</p> <p>Row-wise maxima separated by a minimum distance form candidate lane points. The first valid pair above the vehicle seed two sets of points that are tracked upward row by row. The final polylines are smoothed with a cubic B-spline to produce left/right boundaries $L$ and $R$.</p>"},{"location":"technical_reference/#planning-geometric-and-speed-references","title":"Planning: geometric and speed references","text":""},{"location":"technical_reference/#waypoint-generation","title":"Waypoint generation","text":"<p>The waypoint planner fits a centreline spline by minimizing a curvature regularised functional</p> <p>$$ J(C) = \\sum_{i=1}^{N} |C(s_i) - m_i|_2^2 + \\beta \\int \\kappa(s)^2\\, ds, $$</p> <p>where $m_i$ are midpoints between $L$ and $R$, $\\kappa(s)$ is the spline curvature, and $\\beta$ is the smoothing weight (<code>planning.waypoints.smoothing_beta</code>). The planner outputs $N$ waypoints expressed in the vehicle frame.</p>"},{"location":"technical_reference/#target-speed-prediction","title":"Target-speed prediction","text":"<p>Curvature-driven speed selection uses the reciprocal curvature $\\kappa$ of the centreline:</p> <p>$$ \\hat{v} = \\operatorname{clip}\\left( v_{\\min}, v_{\\max}, v_{\\max} - K_v\\, |\\kappa| \\right), $$</p> <p>with gains configured via <code>planning.target_speed</code>. The planner optionally averages multiple forward-looking waypoints to damp oscillations.</p>"},{"location":"technical_reference/#control-vehicle-dynamics-simplifications","title":"Control: vehicle dynamics simplifications","text":""},{"location":"technical_reference/#lateral-steering-stanley-method","title":"Lateral steering (Stanley method)","text":"<p>The Stanley controller combines heading error $\\psi_k$ and cross-track error $d_k$:</p> <p>$$ \\delta_k = \\psi_k + \\arctan\\left(\\frac{k_s d_k}{v_k + \\varepsilon}\\right) - \\lambda (\\delta_k - \\delta_{k-1}), $$</p> <p>where $k_s$ is the gain (<code>control.lateral.gain_constant</code>) and $\\lambda$ is the first-order damping term (<code>control.lateral.damping_constant</code>). Image-frame waypoints $(x_{\\text{img}}, y_{\\text{img}})$ are rotated into a vehicle-centric frame by treating $y_{\\text{img}}$ as the forward axis and centring $x_{\\text{img}}$ around <code>control.lateral.vehicle_center_x</code>. The command is clipped to <code>control.lateral.steering_limit</code> radians (default $\\pm 0.4$ rad) and rescaled to $[-1,1]$ before submission.</p>"},{"location":"technical_reference/#longitudinal-pid-control","title":"Longitudinal PID control","text":"<p>Throttle/brake are derived from a discrete PID law applied to the speed error $e_k = v^*_k - v_k$:</p> <p>$$ \\begin{aligned} P_k &amp;= K_P e_k,\\ I_k &amp;= I_{k-1} + K_I e_k \\Delta t,\\ D_k &amp;= K_D \\frac{e_k - e_{k-1}}{\\Delta t},\\ u_k &amp;= P_k + I_k + D_k. \\end{aligned} $$</p> <p>The integral term is clamped to <code>control.longitudinal.integral_windup_limit</code>. Positive $\\nu_k$ commands throttle while negative $\\nu_k$ maps to brake pressure, both bounded by <code>control.longitudinal.max_gas</code> and <code>control.longitudinal.max_brake</code>.</p>"},{"location":"technical_reference/#configuration-surface","title":"Configuration surface","text":"<p>All tunable parameters live in <code>config.yml</code> and mirror the dataclasses in <code>src/configuration.py</code>:</p> <ul> <li><code>perception.lane_detection.*</code> controls cropping, spline smoothness, and   gradient thresholds.</li> <li><code>planning.waypoints</code> sets waypoint count, interpolation model (<code>way_type</code>),   and smoothing weight.</li> <li><code>planning.target_speed</code> configures curvature gain and admissible speed range.</li> <li><code>control.lateral</code> exposes the Stanley gains, image-to-vehicle alignment, and   steering saturation limit, while <code>control.longitudinal</code> contains the PID   coefficients.</li> <li><code>monitoring.dashboard</code> toggles the live Matplotlib dashboard and the length of   its rolling history window.</li> <li><code>runtime.*</code> chooses episode horizon and timestep.</li> <li><code>environment.*</code> specifies the Gymnasium environment ID, render mode, and   wrapper behaviour.</li> </ul> <p>Switch configurations at runtime via</p> <pre><code>python modular_pipeline.py --config custom.yml\n</code></pre>"},{"location":"technical_reference/#verification-and-testing","title":"Verification and testing","text":"<p>Automated tests cover module contracts as well as the orchestrator wiring:</p> <ul> <li>Unit tests in <code>tests/</code> validate perception, planning, and control behaviours.</li> <li><code>tests/test_pipeline_integration.py</code> instantiates a synthetic environment and   stub modules to verify that resets, context propagation, and command   aggregation all operate correctly.</li> <li><code>mkdocs build</code> ensures the documentation renders without warnings.</li> </ul>"},{"location":"technical_reference/#live-telemetry-and-observers","title":"Live telemetry and observers","text":"<p><code>ModularPipeline</code> accepts optional observers implementing the <code>PipelineObserver</code> protocol. An observer receives the full step context</p> <p>$$ \\Xi_k = {x_k,\\ \\mathcal{L}_k,\\ \\mathcal{P}_k,\\ u_k,\\ r_k,\\ v_k}, $$</p> <p>where $x_k$ is the rendered frame, $\\mathcal{L}_k$ the perception output, $\\mathcal{P}_k$ the planning state, $u_k$ the control command, and $r_k$ the reward. The built-in <code>LiveDashboard</code> observer (enabled by default) renders this stream with four synchronized panes:</p> <ol> <li>Observation preview.</li> <li>Lane boundaries and centreline waypoints.</li> <li>Target speed $v^*_k$ versus measured velocity $v_k$.</li> <li>Normalized steering, throttle, and brake commands.</li> </ol> <p>The dashboard is invaluable when tuning controller gains: deviations between $v^*_k$ and $v_k$ immediately highlight PID misconfiguration, while steering oscillations show up as large gradients in the command trace. Disable the dashboard in headless environments via <code>--no_display</code> or by setting <code>monitoring.dashboard.enabled</code> to <code>false</code> in <code>config.yml</code>.</p>"},{"location":"technical_reference/#extensibility-guidelines","title":"Extensibility guidelines","text":"<ol> <li>Implement the appropriate protocol from <code>src/pipeline/interfaces.py</code>    (<code>PerceptionModule</code>, <code>PlanningModule</code>, or <code>ControlModule</code>).</li> <li>Register the new module in <code>build_pipeline</code> or compose it programmatically.</li> <li>Declare any new hyper-parameters in <code>config.yml</code> and extend the    configuration dataclasses.</li> <li>Document the mathematical model and tuning recommendations in this manual.</li> </ol> <p>The modular structure allows researchers to experiment with advanced perception (e.g. neural lane segmentation), nonlinear model predictive control, or reinforcement learning components while preserving a reproducible evaluation harness.</p>"},{"location":"testing/","title":"Testing and Validation","text":"<p>The simulator is the ground truth for this stack. Use the following recommendations to evaluate changes consistently.</p>"},{"location":"testing/#unit-level-checks","title":"Unit-level checks","text":"<ul> <li>Lane detection \u2013 run against stored screenshots and assert spline validity   (<code>t</code>, <code>c</code>, <code>k</code> shapes, finite coefficients).</li> <li>Waypoint prediction \u2013 feed synthetic splines (straight line, S-curve) and   verify that the smoothing objective reduces curvature as expected.</li> <li>Longitudinal PID \u2013 simulate a step response with a target speed profile   and ensure the gas/brake outputs stay within <code>[0, 0.8]</code>.</li> </ul>"},{"location":"testing/#integration-loops","title":"Integration loops","text":"<p>Run the orchestrator with the standard settings:</p> <pre><code>python modular_pipeline.py --no_display\n</code></pre> <p>Expected behaviour:</p> <ol> <li>Vehicle remains centred in the lane without oscillatory steering.</li> <li>Target speed ramps up on straight sections and drops before sharp turns.</li> <li>Episode rewards should be positive and stable across seeds.</li> </ol> <p>For regression testing, the helper <code>calculate_score_for_leaderboard</code> evaluates the seeds specified under <code>evaluation.score_seeds</code> in <code>config.yml</code> and prints the clipped reward per episode followed by the mean score.</p>"}]}